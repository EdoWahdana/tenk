// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.0.1) 


///  Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
type token-id = string
type account-id = string
type base64-vec-u8 = string
type u128 = string

record token {
    token-id: token-id,
	owner-id: account-id,
	metadata: option<token-metadata>,
	approved-account-ids: option<list<tuple<account-id,u64>>>
}

///  Metadata on the individual token level.
record token-metadata {
    title: option<string>,
	description: option<string>,
	media: option<string>,
	media-hash: option<base64-vec-u8>,
	copies: option<u64>,
	issued-at: option<string>,
	expires-at: option<string>,
	starts-at: option<string>,
	updated-at: option<string>,
	extra: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Metadata for the NFT contract itself.
record nft-contract-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	base-uri: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

type public-key = string


///  change
update-allowance: function(allowance: u32)

///  change
transfer-ownership: function(new-owner: account-id)

///  change
nft-approve: function(token-id: token-id, account-id: account-id, msg: option<string>)

///  view
whitelisted: function(account-id: account-id) -> bool


///  view
total-cost: function(num: u32, minter: account-id) -> u128


///  change
nft-mint-many: function(num: u32) -> list<token>


///  change
start-premint: function(duration: u64)

///  view
nft-payout: function(token-id: string, balance: u128, max-len-payout: option<u32>) -> payout


///  change
nft-transfer-call: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>, msg: string)

///  change
nft-transfer-payout: function(receiver-id: account-id, token-id: string, approval-id: option<u64>, memo: option<string>, balance: u128, max-len-payout: option<u32>) -> payout


///  view
token-storage-cost: function() -> u128


record initial-metadata {
    name: string,
	symbol: string,
	uri: string,
	icon: option<string>,
	spec: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Create a pending token that can be claimed with corresponding private key
///  change
create-linkdrop: function(public-key: public-key)

///  view
remaining-allowance: function(account-id: account-id) -> u32


///  change
add-whitelist-accounts: function(accounts: list<account-id>, allowance: option<u32>)

///  view
tokens-left: function() -> u32


record sale {
    royalties: option<royalties>,
	initial-royalties: option<royalties>,
	is-premint: option<bool>,
	is-premint-over: option<bool>,
	allowance: option<u32>
}

///  change
end-premint: function(base-cost: u128, min-cost: u128, percent-off: option<u8>)

///  view
check-key: function(public-key: public-key) -> bool


///  view
discount: function(num: u32) -> u128


///  view
nft-total-supply: function() -> u128


///  view
nft-supply-for-owner: function(account-id: account-id) -> u128


///  change
nft-transfer: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>)

///  change
nft-revoke-all: function(token-id: token-id)

///  change
update-royalties: function(royalties: royalties) -> option<royalties>


///  view
cost-per-token: function(num: u32, minter: account-id) -> u128


///  view
nft-metadata: function() -> nft-contract-metadata


///  change
new: function(owner-id: account-id, metadata: nft-contract-metadata, size: u32, price-structure: price-structure, sale: sale)

///  Returns the balance associated with given key.
///  view
get-key-balance: function() -> u128


///  change
nft-revoke: function(token-id: token-id, account-id: account-id)

///  view
nft-is-approved: function(token-id: token-id, approved-account-id: account-id, approval-id: option<u64>) -> bool


///  view
get-linkdrop-contract: function() -> account-id


///  view
cost-of-linkdrop: function(minter: account-id) -> u128


///  change
nft-mint: function(token-id: token-id, token-owner-id: account-id, token-metadata: token-metadata) -> token


///  view
nft-token: function(token-id: token-id) -> option<token>


type basis-point = u16

///  change
new-default-meta: function(owner-id: account-id, metadata: initial-metadata, size: u32, price-structure: price-structure, sale: option<sale>)

///  change
add-whitelist-account-ungaurded: function(account-id: account-id, allowance: u32)

///  Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation
///  A mapping of NEAR accounts to the amount each should be paid out, in
///  the event of a token-sale. The payout mapping MUST be shorter than the
///  maximum length specified by the financial contract obtaining this
///  payout data. Any mapping of length 10 or less MUST be accepted by
///  financial contracts, so 10 is a safe upper limit.
///  This currently deviates from the standard but is in the process of updating to use this type
record payout {
    payout: list<tuple<account-id,u128>>
}

record price-structure {
    base-cost: u128,
	min-cost: option<u128>,
	percent-off: option<u8>
}

///  change
nft-mint-one: function() -> token


record royalties {
    accounts: list<tuple<account-id,basis-point>>,
	percent: basis-point
}

